Software Requirements Specification
for
AI-Assisted Symbolic Execution
for Testing and Repairing Software Systems
Version 1.0
Prepared by:
Harshita Jain (23UCC547)
Himanshi Bhamu(23UCC549)
Yashi Srivastava(23UCC620)
Under the Guidance of:
Dr. Ashish Kumar Dwivedi
Dr. Anubhav Shivhare
Course: Software Development Lab
The LNM Institute of Information Technology, Jaipur
Date: October 10, 2025
AI-Assisted Symbolic Execution SRS Version 1.0
Revision History
Version Date Description
1.0 October 10, 2025 Initial draft of SRS completed
Contents
1 Introduction 1
1.1 Document Purpose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 Product Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.3 Definitions, Acronyms, and Abbreviations . . . . . . . . . . . . . . . . . . 2
1.4 References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.5 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
2 Overall Description 3
2.1 Product Perspective . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.2 Product Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.3 User Characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2.4 Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2.5 Assumptions and Dependencies . . . . . . . . . . . . . . . . . . . . . . . . 5
3 Specific Requirements 6
3.1 External Interface Requirements . . . . . . . . . . . . . . . . . . . . . . . . 6
3.1.1 User Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
3.1.2 Hardware Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
3.1.3 Software Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
3.2 Functional Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
3.3 Non-Functional Requirements . . . . . . . . . . . . . . . . . . . . . . . . . 8
3.4 System Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
3.4.1 Symbolic Execution Engine . . . . . . . . . . . . . . . . . . . . . . 8
3.4.2 AI-Assisted Path Prioritization . . . . . . . . . . . . . . . . . . . . 8
3.4.3 Constraint Solving Module . . . . . . . . . . . . . . . . . . . . . . . 8
3.4.4 AI Repair Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.5 System Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.6 Performance Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.7 Design Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.8 Software System Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . 10
i
AI-Assisted Symbolic Execution SRS Version 1.0
4 Software Development Model 11
4.1 Chosen Model: Spiral Model . . . . . . . . . . . . . . . . . . . . . . . . . . 11
4.2 Justification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
5 UML Diagrams 12
5.1 Use Case Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
5.2 Class Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
5.3 Sequence Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
5.4 Data Flow Diagram - Level 0 . . . . . . . . . . . . . . . . . . . . . . . . . 14
5.5 Data Flow Diagram - Level 1 . . . . . . . . . . . . . . . . . . . . . . . . . 15
5.6 Decision Flow Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
6 Appendices 16
6.1 Future Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
6.2 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
6.3 Group Log . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
ii
AI-Assisted Symbolic Execution SRS Version 1.0
1 Introduction
1.1 Document Purpose
This Software Requirements Specification (SRS) document describes the requirements
for the AI-Assisted Symbolic Execution for Testing and Repairing Software
Systems project. The document outlines functional, non-functional, and interface re-
quirements, along with system behavior, user interactions, and design constraints.
The intended audience includes:
• Project development team members
• Supervising faculty and evaluators
• Quality assurance team
• Future developers and researchers
1.2 Product Scope
Traditional software testing relies on manually-designed test cases that often miss edge
cases and hidden bugs. Symbolic Execution (SE) systematically explores multiple
execution paths using symbolic inputs to uncover deep software errors. However, SE
faces major challenges:
• Path Explosion: Exponential growth of paths with program complexity
• Constraint Complexity: Difficulty solving complex mathematical constraints
• Limited Repair: Insufficient automation in bug fixing
• Resource Intensity: High computational requirements
This project integrates AI-based path prioritization and automated repair with
symbolic execution to:
1. Automatically generate comprehensive test cases
2. Intelligently prioritize execution paths using machine learning
3. Identify and localize software bugs accurately
4. Suggest automated code repairs using Large Language Models (LLMs)
5. Validate repaired code through re-execution
The system supports C/C++ programs and serves as a proof-of-concept for intel-
ligent testing frameworks, particularly valuable for embedded systems, security-critical
applications, and educational purposes.
1
AI-Assisted Symbolic Execution SRS Version 1.0
1.3 Definitions, Acronyms, and Abbreviations
Term Definition
SE Symbolic Execution - Program analysis using symbolic values
AI Artificial Intelligence
SMT Satisfiability Modulo Theories - Logic for constraint solving
LLM Large Language Model - AI model trained on code
Z3 SMT solver by Microsoft Research
KLEE Symbolic execution engine on LLVM
CFG Control Flow Graph
AST Abstract Syntax Tree
1.4 References
1. IEEE Std 830-1998: Software Requirements Specifications
2. Cadar, C., et al. ”KLEE: Automatic Generation of High-Coverage Tests.” OSDI,
2008
3. Microsoft Z3 Solver - https://github.com/Z3Prover/z3
4. KLEE Symbolic Execution Engine - https://klee.github.io/
1.5 Overview
The remainder of this document is organized as follows:
• Section 2: Overall system description, functions, and constraints
• Section 3: Detailed functional and non-functional requirements
• Section 4: Software development model and justification
• Section 5: UML diagrams
• Section 6: Appendices
2
AI-Assisted Symbolic Execution SRS Version 1.0
2 Overall Description
2.1 Product Perspective
The system is a standalone testing and analysis framework that integrates into modern
development workflows. It consists of four major subsystems:
1. Symbolic Execution Core: Built on KLEE engine, parses C/C++ code into
LLVM IR, generates symbolic paths, and maintains path conditions
2. AI Path Prioritization Module: Extracts path features, employs ML models to
predict bug-finding likelihood, and dynamically ranks paths
3. Constraint Solving Module: Integrates Z3 SMT solver for path feasibility and
test input generation
4. AI Repair Engine: Uses pre-trained code models (CodeT5, CodeGen, GPT) to
analyze bugs and generate repair candidates
The system operates offline and can be invoked via CLI for CI/CD integration or
through a web-based dashboard for interactive analysis.
2.2 Product Functions
The main functions include:
Stage 1: Code Analysis
• Accept and validate C/C++ source files
• Compile to LLVM bitcode
• Configure symbolic variables
Stage 2: Path Exploration
• AI-prioritized symbolic execution
• Constraint collection and management
• Coverage tracking
Stage 3: Bug Detection
• Multi-type fault detection (buffer overflow, null pointer, division-by-zero, etc.)
• Test case generation with Z3 solver
• Bug context collection and severity classification
3
AI-Assisted Symbolic Execution SRS Version 1.0
Stage 4: AI-Powered Repair
• Bug context preparation for LLM
• Generate and rank repair candidates
• Validate repairs through re-analysis
Stage 5: Reporting
• Generate summary reports and visualizations
• Export in multiple formats (HTML, PDF, JSON)
2.3 User Characteristics
User Type Description Expertise
Software Developers Test code during development Intermediate-Advanced
QA Engineers Generate test suites Intermediate
Security Researchers Discover vulnerabilities Advanced
Students Learn symbolic execution Beginner-Intermediate
2.4 Constraints
Technical Constraints:
• Operating System: Linux (Ubuntu 20.04+) or macOS
• Python 3.9+, KLEE 2.3+, Z3 4.8.12+
• Memory: 8GB RAM minimum (16GB recommended)
• Primary language support: C/C++ (C++14 standard)
• Target programs: 100-2000 lines of code
AI Model Constraints:
• GPU with 4GB+ VRAM recommended
• Internet connection for cloud LLM APIs
• 20GB storage for models
4
AI-Assisted Symbolic Execution SRS Version 1.0
2.5 Assumptions and Dependencies
Assumptions:
• Input code is syntactically correct and compilable
• Sufficient computational resources available
• Users understand basic testing concepts
• Pre-trained ML models are accessible
Dependencies:
• KLEE symbolic execution engine
• Z3 SMT solver
• LLVM/Clang compiler
• PyTorch/Transformers for AI models
• Flask/Streamlit for web interface
5
AI-Assisted Symbolic Execution SRS Version 1.0
3 Specific Requirements
3.1 External Interface Requirements
3.1.1 User Interfaces
The system provides two interfaces:
1. Web Dashboard (Primary)
• Code upload and configuration panel
• Real-time analysis dashboard with progress tracking
• Results visualization with bug reports
• Repair suggestion interface (split-view editor)
• Export and reporting section
2. Command-Line Interface
ai-symbex [options] <source_file.c>
Options:
--symbolic-args N Number of symbolic arguments
--max-time T Maximum time in seconds
--max-paths N Path exploration limit
--ai-model PATH Path to ML model
--repair-model NAME LLM for repairs (codegen|codet5|gpt)
--output-dir DIR Output directory
--report-format FMT Format (html|pdf|json)
3.1.2 Hardware Interfaces
Minimum Requirements:
• CPU: Dual-core 2.5 GHz (x86 64)
• RAM: 8 GB
• Storage: 10 GB free space
Recommended:
• CPU: Quad-core 3.0+ GHz
• RAM: 16 GB
• GPU: NVIDIA with 4GB+ VRAM
6
AI-Assisted Symbolic Execution SRS Version 1.0
3.1.3 Software Interfaces
Component Interface
KLEE Command-line and Python bindings for symbolic execution
Z3 Solver Python API (z3-solver package) for constraint solving
LLVM/Clang Command-line tools for compilation
PyTorch ML framework for path prioritization model
Transformers LLM integration (Hugging Face)
Flask/Streamlit Web framework for UI
3.2 Functional Requirements
ID Requirement Description
FR1 Program Input User uploads C/C++ source code via web or
CLI
FR2 Code Validation System validates syntax and compiles to
LLVM bitcode
FR3 Symbolic Configura-
tion
User configures symbolic variables (types,
ranges, constraints)
FR4 Path Exploration System explores paths using KLEE with AI
prioritization
FR5 Constraint Solving Z3 solver evaluates path feasibility and gen-
erates test inputs
FR6 Fault Detection Detect buffer overflows, null pointers,
division-by-zero, memory leaks, etc.
FR7 Test Generation Generate concrete test cases with harness
code
FR8 Bug Classification Classify bugs by severity (Critical, High,
Medium, Low)
FR9 AI Repair LLM generates multiple repair candidates
with explanations
FR10 Repair Validation Re-execute symbolic analysis on repaired
code
FR11 Reporting Generate summary and detailed bug reports
FR12 Visualization Display execution tree, coverage heatmap,
bug distribution
FR13 Export Export reports in HTML, PDF, JSON for-
mats
7
AI-Assisted Symbolic Execution SRS Version 1.0
ID Requirement Description
Table 5: Functional Requirements
3.3 Non-Functional Requirements
ID Requirement Target
NFR1 Analysis Speed (small programs
¡200 LOC)
¡5 minutes
NFR2 Analysis Speed (medium 200-500
LOC)
¡15 minutes
NFR3 AI Inference Latency (path prior-
itization)
¡100ms per path
NFR4 Memory Usage ¡8GB for typical programs
NFR5 Bug Detection Accuracy ¿85% true positive rate
NFR6 False Positive Rate ¡20%
NFR7 System Availability 99.9% uptime
NFR8 Code Isolation Execute in sandbox environment
NFR9 Data Encryption HTTPS for web, encrypted storage
NFR10 Usability New users productive within 30 minutes
3.4 System Features
3.4.1 Symbolic Execution Engine
• Parse program syntax tree and generate CFG
• Create symbolic variables and track path conditions
• Manage symbolic memory
3.4.2 AI-Assisted Path Prioritization
• Extract features: branch complexity, constraint count, coverage potential
• ML model (Random Forest/Gradient Boosting) predicts bug likelihood
• Dynamic path ranking and selection
3.4.3 Constraint Solving Module
• Translate KLEE constraints to Z3 format
8
AI-Assisted Symbolic Execution SRS Version 1.0
• Check satisfiability and generate concrete values
• Incremental solving with caching
3.4.4 AI Repair Module
• Prepare bug context with code, error type, path conditions
• LLM generates repair candidates
• Rank by compilation success, test pass rate, code quality
• Validate through re-analysis
3.5 System Flow
1. User uploads program
2. System validates and compiles to LLVM bitcode
3. Symbolic execution explores paths with AI prioritization
4. Z3 solver checks path feasibility
5. Bugs are detected and classified
6. Test cases generated for each bug
7. AI generates repair suggestions
8. Repairs validated through re-analysis
9. Final report with visualizations generated
3.6 Performance Requirements
• Handle up to 1000 concurrent paths
• Support programs with 100+ functions
• Process 10+ analyses per hour
• Solver timeout: 30 seconds per query
9
AI-Assisted Symbolic Execution SRS Version 1.0
3.7 Design Constraints
• Written in Python 3.9+
• Uses KLEE, Z3, PyTorch, Transformers
• Web UI built with Flask or Streamlit
• Modular architecture for maintainability
3.8 Software System Attributes
Reliability:
• Graceful handling of malformed input
• Recovery from tool failures
• Automatic checkpointing
Security:
• Sandbox execution environment
• Encrypted data storage
• Role-based access control
Maintainability:
• Modular design with clear APIs
• Comprehensive logging
• Well-documented code
Portability:
• Cross-platform (Linux, macOS)
• Docker containerization support
10
AI-Assisted Symbolic Execution SRS Version 1.0
4 Software Development Model
4.1 Chosen Model: Spiral Model
The Spiral Model has been selected for this project, combining structured phases with
iterative, flexible development. This is ideal for research-oriented projects involving AI
and symbolic execution.
4.2 Justification
• Complex Components: Multiple subsystems (SE, AI, Z3) require experimenta-
tion and tuning
• Risk Management: Iterative cycles allow for continuous risk assessment
• Prototype Evolution: System evolves gradually through repeated planning, im-
plementation, and evaluation
• Flexibility: Accommodates changes based on testing feedback and new insights
• Integration Challenges: Allows for incremental integration of KLEE, Z3, and AI
models
Spiral Phases for This Project:
1. Planning: Requirements analysis, tool selection
2. Risk Analysis: Identify challenges (path explosion, AI accuracy)
3. Engineering: Implement symbolic execution, integrate AI, develop UI
4. Evaluation: Test on benchmark programs, gather feedback, refine
11
AI-Assisted Symbolic Execution SRS Version 1.0
5 UML Diagrams
5.1 Use Case Diagram
Figure 1: Use Case Diagram illustrating system actors and their interactions.
12
AI-Assisted Symbolic Execution SRS Version 1.0
5.2 Class Diagram
Figure 2: Class diagram showing system components and relationships.
5.3 Sequence Diagram
Figure 3: Sequence diagram depicting the message flow between modules.
13
AI-Assisted Symbolic Execution SRS Version 1.0
5.4 Data Flow Diagram - Level 0
Figure 4: Data Flow Diagram - Level 0 (Context Diagram)
14
AI-Assisted Symbolic Execution SRS Version 1.0
5.5 Data Flow Diagram - Level 1
Figure 5: Data Flow Diagram - Level 1 showing internal data movement.
15
AI-Assisted Symbolic Execution SRS Version 1.0
5.6 Decision Flow Diagram
Figure 6: Decision Flow Diagram representing symbolic execution process.
6 Appendices
6.1 Future Enhancements
• Extend language support to Java and Python
• Implement reinforcement learning for adaptive path prioritization
• Add parallel symbolic execution for faster analysis
16
AI-Assisted Symbolic Execution SRS Version 1.0
• Integrate with CI/CD pipelines (Jenkins, GitHub Actions)
• Support for complex C++ features (templates, exceptions)
• Real-time collaborative debugging interface
• Mobile app for monitoring analysis progress
6.2 Glossary
Term Definition
Symbolic Variable Variable representing a set of possible concrete values for analysis
Path Condition Logical formula describing constraints for an execution path
Path Explosion Exponential growth in number of paths to explore
SMT Solver Tool determining if a logical formula is satisfiable
Constraint Solver System that finds values satisfying given constraints
Concolic Execution Concrete + Symbolic execution (hybrid approach)
Test Harness Code framework for executing and validating test cases
False Positive Bug report for code that is actually correct
Coverage Metric Measure of code executed during testing (line, branch, path)
6.3 Group Log
Date Activity
12/09/2025 Project allotment and initial meeting
14/09/2025 Literature review on symbolic execution and AI techniques
19/09/2025 Tool selection (KLEE, Z3) and architecture design
25/09/2025 Prototype development commenced
05/10/2025 First draft of SRS completed
10/10/2025 Final SRS version with revisions
17